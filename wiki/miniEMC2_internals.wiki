#summary miniEMC2 internal structure and differences from the original EMC2.

= miniEMC2 - what is it? =
Why Linux and EMC2? I would say the idea of implementation of G-code interpreter from scratch is not very simple task and author hardly would started such a project considering it as a hobby. But he would like to implement something cheap and simple. He even managed to find clipped EMC2 project ( detached from Linux and used no OS ) and pack in into small ARM7 MCU - thanks to guys from here http://www.oemtech.com/gcodecompiler/. But, performance of that MCU was not very well and small amount of internal memory added some restrictions. However, it was some years ago and and new generation of Cortex-M4 now is fast enough to satisfy that requirements. But in the author's mind appeared idea to port core of EMC2 project to embedded Linux device. That time a widely used board was mini2440, so it was decided to use one for experiments.
First attempts to build EMC2 in simulation mode showed satisfying results ( it's valid for EMC2 version 2.2.0, but with 2.4.0 ,seems, requires much more computation ). It was the version without GUI and HAL drivers-system was controlled over Ethernet with TkEMC. The next task was an implementation of Hard RealTime with such accuracy to be able to make step pulses with acceptable frequency and jitter. The solution appeared unexpectedly when author was looking over source code of  GTA02 project and found there an interesting trick with Fast Interrupt reQuest ( FIQ). FIQ is similar to usual IRQ, but response time is high little bit and the main advantage FIQ have the highest priority and they don't have any infrastructure in the kernel. Usual IRQ is wrapped in special handlers and demultiplexers, the can be disabled at the any time. But FIQ don't any of this disadvantages.  That way they suited well to be use for pseudo Hard Real-Time system. Measured latency was about 1-3 uS, that was enough to count on them. But FIQ it's only the half of the problem. Second problem was to ensure also more "soft" real time for trajectory computation. The solution was found when Xenomia's developer added S3C2440 support to I-PIPE. Test showed latency about 100 uS under high I/O load. Not the best result, but was decided to try port RTAPI to Xenomai. To simplify the porting task was decided to substituted LIBPTH calls with wrapped Xenomai Native skin's calls using SIM_RTAPI port as a base. As a result we have next project structure:

http://3.bp.blogspot.com/-VmAM5UCNsIs/ToTLogTzFiI/AAAAAAAAAAY/Uh9Lzn5izDI/s1600/miniemc2_funcd.png

 Это было очень неплохо и в результате была создана следующая структура EMC2 для mini2440: